#lang racket
(define (limit-function a b)
  (define y (/ (* (sqrt (+ (* a a)(* b b))) (abs (- b a))) (* 2 (sqrt (+ (* (- b a) (- b a)) (* (+ a b) (+ a b))))) ))
  (define x (/ (* (sqrt (+ (* a a)(* b b))) (+ b a)) (* 2 (sqrt (+ (* (- b a) (- b a)) (* (+ a b) (+ a b)))) )))
  (define (first-m k l) (<= (- (+ k y) x) l))
  (define (second-m k l) (>= (+ (- x k) y) l))
  (define (third-m k l) (>= (- (+ x k) y) l))
  (define (fourth-m k l) (<= (- (* -1 (+ x k)) y) l))
  (define start-x (* -1 (exact-floor x)))
  (define start-y start-x)
  (define size (expt (* (+ (* (exact-floor x) 2) 1)) 2))
  (define (create-list-x list-x start-x )
    (if (<= start-x x) (let((list-x (cons start-x list-x ))) (create-list-x list-x (+ 1 start-x)) ) list-x))
  (define (create-list-y list-y start-y )
    (if (<= start-y x) (let (( list-y (cons start-y list-y ))) (create-list-y list-y (+ 1 start-y))) list-y))
  (define (nth idx lst)
  (cond ((empty? lst) "empty")
        ((= idx 0) (first lst))
        (else (nth (- idx 1) (rest lst)))))
  (define list-x (create-list-x '() start-x))
  (define list-y (create-list-y '() start-y))
  (define (calculate size list-x list-y iterator-x iterator-y)
    (if (< iterator-x (length list-x))
          (let ((k (nth iterator-x list-x)))
            (if (< iterator-y (length list-y))
            (let ((l (nth iterator-y list-y)))
              (if (and (first-m k l) (second-m k l) (third-m k l) (fourth-m k l))
                  (calculate size list-x list-y iterator-x (+ iterator-y 1))
                  (calculate (- size 1) list-x list-y iterator-x (+ iterator-y 1)))
  ) (calculate size list-x list-y (+ iterator-x 1) 0))
            ) size))
  (calculate size list-x list-y 0 0)
  )
(limit-function 8 6) ;49
(limit-function 6 4) ;23 olmalÄ±
(limit-function 30 2) ;65
(limit-function 16 20) ;333